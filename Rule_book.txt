1. Code Quality Expectations

Write production-grade, industry-level code — no shortcuts.

Use clear, consistent naming based on domain meaning, not laziness.

Avoid magic numbers, hidden assumptions, and implicit behavior.

Structure code so it scales, not so it “just works”.

2. Error Handling Requirements

Never assume success — handle all failure paths explicitly.

Return meaningful error messages, not generic placeholders.

Validate inputs aggressively (type, shape, range, nullability).

Fail safely — no silent failures or swallowed exceptions.

3. Edge Case Thinking

You must explicitly consider:

missing/undefined/null inputs

invalid types

empty arrays/objects

concurrency conflicts

network timeouts

rate limits

database inconsistencies

race conditions

authentication/authorization gaps

security vulnerabilities (XSS, SQLi, CSRF, injection)

4. Architecture & Structure

Separate concerns — no god functions or tangled logic.

Use abstraction only when it reduces complexity, not increases it.

Add comments only where reasoning is non-obvious — no narration comments.

5. Testing Expectations

Include test cases for:

normal flow

boundary conditions

invalid input

failure handling

If tests are skipped, explicitly state why.

6. Documentation Requirements

Provide:

a short explanation of core logic

assumptions

limitations

possible failure modes

how to extend safely

7. Output Formatting

Your output MUST include:

Final code

Explanation of decisions

Edge cases considered

Example usage

Error behaviour description

8. Forbidden Behaviors

Do NOT:

write code that only works for the happy path

ignore security considerations

provide pseudo-code unless asked

produce oversimplified toy implementations

say “basic example” or “you can improve it later”

rely on global state unless justified
